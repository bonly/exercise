// Author: likunarmstrong@gmail.com

/* 
 * Go version of concurrent arithmetical card game 24 game. Just for fun.
 * Division is not supported.
 * 
 * The program is running like a pipeline. All results from combination of 2
 * numbers are calculated concurrently and each result is sent to later stage
 * once ready. The same process is repeated for combinations of 3, 4 numbers.
 * Once the stage for 4 numbers combinations is done, we know all possiblilities
 * of the result of 4 numbers combinations, we then print out the ones
 * generating result of 24.
 *
 * To use it, simply run this one as a script, like "gorun 24.go"
 */

package main
import ("fmt";"strconv";)

type typeData struct {
        key int
        mask int
        data []int
        exp []string
}

var (
        // Supported operators
        oprs = []byte{'+', '-', '*'}
)

/*
 * Calculate all the combinations of arithmetic between a and b, mark the
 * position in mask based on i(index of a) and j(index of b), and generate
 * corresponding string of expression based on pre and string(b).
 *
 * Note that a could be a digit or a result of combination from previous stage,
 * in which case i should be 0 and pre should be the expression of previous
 * combination
 */
func calc(a, b, i, j, bm int, pre string, result chan typeData) {
        // We use number to construct key to avoid repeated calculation in case
        // there are two same number
        key := a * 10 + b
        mask := bm
        if i != -1 { mask |= 1 << uint(i) }
        mask |= 1 << uint(j)
        r := make([]int, 0)
        exp := make([]string, 0)
        for _, o := range oprs {
                exp = append(exp, fmt.Sprintf("(%s%c%d)", pre, o, b))
                switch o {
                case '+':
                        r = append(r, a + b)
                case '-':   // minus is not bidirectional
                        r = append(r, a - b)
                        r = append(r, b - a)
                        exp = append(exp, fmt.Sprintf("(%d%c%s)", b, o, pre))
                case '*':
                        r = append(r, a * b)
                }
        }
        result <- typeData{key, mask, r, exp}
}

// Arbitrarily pick two of the numbers and calculate all possible arithmetic
// result
func oneCombinations(out chan typeData, input []int) chan bool {
        done := make(chan bool)
        go func() {
                result := make(chan typeData)
                size := len(input)
                kidsInAction := 0
                for i := 0; i < size; i++ {
                        for j := i + 1; j < size; j++ {
                                // Key of map is a bit vector
                                go calc(input[i], input[j], i, j, 0, strconv.Itoa(input[i]), result)
                                kidsInAction++
                        }
                }
                for i := 0; i < kidsInAction; i++ {
                        out <- <-result
                }
                done <- true
        }()
        return done
}

// Calculate all possible arithmetic result of the passed in middle result,
// which is generated by two of the numbers, with any other number which is not
// same as the used two numbers.
// For example, if the given input is 1,2,3,4, and passed in value is 6(2*3),
// then this function calculate all possible results by processing (6,1) and (6.4)
func twoCombinations(in, out chan typeData, preDone chan bool, input []int) chan bool {
        done := make(chan bool)
        go func() {
                result := make(chan typeData)
                kidsInAction := 0
                size := len(input)
                for {
                        select {
                        case r := <-in:
                                dataSize := len(r.data)
                                for i := 0; i < size; i++ {
                                        // If index i is not used in this
                                        // result, we use value at i as
                                        // candidate of next level combination
                                        if (r.mask >> uint(i)) & 0x01 != 1 {
                                                for j := 0; j < dataSize; j++ {
                                                        go calc(r.data[j], input[i], -1, i, r.mask, r.exp[j], result)
                                                        kidsInAction++
                                                }
                                        }
                                }
                        // This branch will only be invoked after all in channel is done with reading
                        case b := <-preDone:
                                for i := 0; i < kidsInAction; i++ {
                                        out <- <-result
                                }
                                done <- b
                                break
                        }
                }
        }()
        return done
}

// Calculate all possible arithmetic result of the passed in middle result,
// which is generated by three of the numbers, with remain one number.
// For example, if the given input is 1,2,3,4, and passed in value is 6(1*2*3),
// then this function calculate all possible results by processing (6.4)
func threeCombinations(in, out chan typeData, preDone chan bool, input []int) chan bool {
        done := make(chan bool)
        go func() {
                result := make(chan typeData)
                kidsInAction := 0
                size := len(input)
                for {
                        select {
                        case r := <-in:
                                //out <- r
                                dataSize := len(r.data)
                                for i := 0; i < size; i++ {
                                        // If index i is not used in this
                                        // result, we use value at i as
                                        // candidate of next level combination
                                        if (r.mask >> uint(i)) & 0x01 != 1 {
                                                for j := 0; j < dataSize; j++ {
                                                        go calc(r.data[j], input[i], -1, i, r.mask, r.exp[j], result)
                                                        kidsInAction++
                                                }
                                        }
                                }
                        case b := <-preDone:
                                for i := 0; i < kidsInAction; i++ {
                                        out <- <-result
                                }
                                done <- b
                                break
                        }
                }
        }()
        return done
}

// Filter the result and print out the correct expression
func fourCombinations(in chan typeData, out chan []byte, preDone chan bool, input []int) chan bool {
        done := make(chan bool)
        go func() {
                flag := false
                for {
                        select {
                        case r := <-in:
                                dataSize := len(r.data)
                                for i := 0; i < dataSize; i++ {
                                        if r.data[i] == 24 {
                                                fmt.Println("here we go: ", r.exp[i])
                                                flag = true
                                        }
                                }
                        case b := <-preDone:
                                if !flag { fmt.Println("Can not find any answer") }
                                done <- b
                                break
                        }
                }
        }()
        return done
}

func solver(input []int) {
        twoCombChan := make(chan typeData)
        threeCombChan := make(chan typeData)
        fourCombChan := make(chan typeData)
        result := make(chan []byte)

        done1 := oneCombinations(twoCombChan, input)
        done2 := twoCombinations(twoCombChan, threeCombChan, done1, input)
        done3 := threeCombinations(threeCombChan, fourCombChan, done2, input)
        done4 := fourCombinations(fourCombChan, result, done3, input)
        <-done4
}

func main() {
        for {
                fmt.Println("\nPleas input your number in format of 1,1,1,1:")
                var a, b, c, d int
                fmt.Scanf("%d,%d,%d,%d", &a, &b, &c, &d)
                input := []int{a, b, c, d}
                solver(input)
        }
}