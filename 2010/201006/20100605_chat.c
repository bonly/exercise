/******************************************************************* 
 * C-file generated by Protoc for Embedded C.                      *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : 20100605_chat.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "20100605_chat.h"
#include "20100603_chat.h"

/*******************************************************************
 * General functions
 *******************************************************************/
 

/*******************************************************************
 * Message: 20100605_chat.proto, line 3
 *******************************************************************/
int ACTION_write(struct ACTION *_ACTION, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = ID_write_with_tag(&_ACTION->_from_id, _buffer, offset, 1);
    offset = ID_write_with_tag(&_ACTION->_to_id, _buffer, offset, 2);
    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    if (_ACTION->_action >= 0)
        offset = write_raw_varint32(_ACTION->_action, _buffer, offset);
    else
        offset = write_raw_varint64(_ACTION->_action, _buffer, offset);

    
    return offset;
}

int ACTION_write_with_tag(struct ACTION *_ACTION, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = ACTION_write_delimited_to(_ACTION, _buffer, offset);
    
    return offset;
}

int ACTION_write_delimited_to(struct ACTION *_ACTION, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = ACTION_write(_ACTION, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void ACTION_clear(struct ACTION *_ACTION) {
    _memset(_ACTION, 0, sizeof(struct ACTION));
}

int ACTION_read(void *_buffer, struct ACTION *_ACTION, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    ACTION_clear(_ACTION);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _ACTION._from_id 
            case 1 :
                offset = ID_read_delimited_from(_buffer, &_ACTION->_from_id, offset);
                break;
            //tag of: _ACTION._to_id 
            case 2 :
                offset = ID_read_delimited_from(_buffer, &_ACTION->_to_id, offset);
                break;
            //tag of: _ACTION._action 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _ACTION->_action = (signed long)tag;
                break;
        }
    }
    
    return offset;
}

int ACTION_read_delimited_from(void *_buffer, struct ACTION *_ACTION, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    ACTION_read(_buffer, _ACTION, offset, size + offset);
    
    return offset + size;
}
